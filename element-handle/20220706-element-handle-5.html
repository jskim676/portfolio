<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    #root {
      width: 100vw;
      height: 100vh;
      background-color: #333;
    }

    #root>div {
      color: #ccc;

      width: inherit;
      height: inherit;

      display: flex;
      justify-content: center;
      align-items: center;

    }

    /* #slide-container*/

    /* slide structuring */
    #slide-container>div:nth-child(1) {
      width: 100px;
      height: 300px;
      background-color: #666;
    }

    #slide-container>div:nth-child(2) {
      width: 300px;
      height: 300px;
      background-color: #666;
    }

    #slide-container>div:nth-child(3) {
      width: 100px;
      height: 300px;
      background-color: #666;
    }

    #slide-img-wrapper {
      position: relative;
    }

    #slide-img-wrapper div {
      position: absolute;
      width: inherit;
      height: inherit;
      color: gray;
    }
  </style>
</head>

<body>
  <div id="root">
    <div id="slide-container">
      <div id="slide-button-left">left</div>
      <div id="slide-img-wrapper">
        <div style="background-color: antiquewhite;">slide-img-1</div>
        <div style="background-color:cadetblue;">slide-img-2</div>
        <div style="background-color: coral;">slide-img-3</div>
        <div style="background-color:gray">slide-img-4</div>
        <div style="background-color: crimson;">slide-img-5</div>
      </div>
      <div id="slide-button-right">right</div>
    </div>
  </div>
  <script>
    const init = {
      root: document.getElementById("root"),
      slide: {
        leftButton: document.getElementById("slide-button-left"),
        imgWrapper: document.getElementById("slide-img-wrapper"),
        imgItems: Array.from(document.querySelectorAll("#slide-img-wrapper > div")).reverse(),
        rightButton: document.getElementById("slide-button-left"),
      }
    }

    const { slide: { imgWrapper, imgItems } } = init;
    /*
    <!--
      ? imgWrapper : 비구조화 할당, 구조분해할당 방식을 통해 객체의 값을 간단히 변수로 얕게 복사한 사례이다.
      * const 상수 "한번" 선언에 사용할 데이터는 두개를 동시에 만들었다.
      * const imgWrapper = init.slide.imgWrapper;
      * const imgItems = init.slide.imgItems; 
      * 기존 방식은 위와 같다.
      -->
    */
    imgWrapper.innerHTML = "";
    /*
      <!--
        ? imgWrapper.innerHTML = "";
        work.1 컨테이너의 역할을 하는 요소의 innerHTML에 접근했다.
        * 기존의 문서 트리구조 (역순으로 바꾸기전) 가 그대로 화면에 출력되어있기 때문에 이것을 마치 자식이 없는 것처럼 처리하기 위해
        * "해당 자식들을 없애줘" 라고 표현하는 removeChild() 메서드 대신
        * "": 문자열 공백을 의미하는 데이터를 '대입' 하는 방식으로
        * 마치 자식요소들을 없앤것과 같은 효과를 만들었다.
        * 사람말로 풀어 설명하면
        * "선택한 요소 자식자리에 문자열로 된 공백을 넣어줘" 가 된다.
        
        pseudo HTML의 정적 처리 방식을 '역'이용하는 아이디어
        * html 로 새겨진 데이터는 프론트엔드에서 "어떤방식으로든" 데이터를 지울수(Delete)는 없다.
        * 대신 위와 같이 '없는 것처럼' 보이게는 할 수 있고, 
        * 데이터를 가져와 가공하는 것도 얼마든지 가능하다.
        * 동적으로 요소를 처리해야하는 상황이라면 다른 방식을 고안하여 작성한다.
        * 
        work.2 정적 처리의 장점(HTML로 작성하는 것)?
        * 기본적으로 '기술요구수준'이 낮다.
        * 다시말해 동료가 자바스크립트를 제대로 사용하지 못하는 경우에도 (보통은 html, css에는 익숙하기 때문에)
        * 동료나 부하직원이 '정적으로 처리한 HTML 문서' 인 경우를 심심찮게 맞이하기 때문이다.
        * 개발, 혹은 다른 데이터 등등 html은 매우 중요한 기본(표준) 이기때문에 모든 코딩을 동적(프로그래밍 언어)으로 작성하는 방식을 채택하진 못한다.
        * 보편화된 html 작성을 역이용하는 사례는 매우 잦은 일이다.
      -->
    */
    imgItems.forEach((imgItems) => imgWrapper.appendChild(imgItems));




  </script>
</body>

</html>